{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://github.com/anthony-spruyt/xfg/config-schema.json",
  "title": "xfg Configuration",
  "description": "Configuration file for xfg CLI tool that syncs JSON, YAML, or text config files across multiple Git repositories",
  "type": "object",
  "required": [
    "id",
    "files",
    "repos"
  ],
  "properties": {
    "id": {
      "type": "string",
      "pattern": "^[a-zA-Z0-9_-]+$",
      "minLength": 1,
      "maxLength": 64,
      "description": "Unique identifier for this config. Used to namespace managed files in .xfg.json manifest, allowing multiple configs to manage the same repo without conflicts."
    },
    "files": {
      "type": "object",
      "description": "Map of target filenames to their configurations. Each file is synced to all repos by default.",
      "minProperties": 1,
      "additionalProperties": {
        "$ref": "#/definitions/fileConfig"
      }
    },
    "repos": {
      "type": "array",
      "description": "List of repository configurations",
      "minItems": 1,
      "items": {
        "$ref": "#/definitions/repo"
      }
    },
    "prOptions": {
      "$ref": "#/definitions/prOptions",
      "description": "Global PR merge options. Can be overridden per-repo."
    },
    "prTemplate": {
      "type": "string",
      "description": "Custom PR body template. Can be inline markdown or a file reference (@path/to/template.md relative to config file). Supports ${xfg:...} templating variables: ${xfg:pr.fileChanges} (bulleted file list), ${xfg:pr.fileCount}, ${xfg:pr.title}, plus all repo variables (repo.name, repo.owner, repo.fullName, etc.)."
    },
    "githubHosts": {
      "type": "array",
      "items": {
        "type": "string",
        "pattern": "^[a-zA-Z0-9][a-zA-Z0-9.-]*[a-zA-Z0-9]$"
      },
      "description": "List of GitHub Enterprise Server hostnames. URLs matching these hosts will be treated as GitHub repositories instead of falling back to GitLab detection. Example: ['github.mycompany.com', 'ghe.internal.net']"
    },
    "deleteOrphaned": {
      "type": "boolean",
      "default": false,
      "description": "Global default for orphan deletion. When true, files removed from the xfg config will be deleted from target repos (tracked via .xfg.json manifest). Can be overridden per-file or per-repo. Default: false"
    },
    "settings": {
      "$ref": "#/definitions/repoSettings",
      "description": "Global repository settings including GitHub Rulesets. Can be overridden per-repo. Settings are merged: per-repo rulesets override root rulesets with same name."
    }
  },
  "definitions": {
    "fileConfig": {
      "type": "object",
      "description": "Configuration for a single file to sync",
      "properties": {
        "content": {
          "oneOf": [
            {
              "type": "object",
              "description": "Object content for JSON/YAML output files (.json, .yaml, .yml)",
              "additionalProperties": true
            },
            {
              "type": "string",
              "description": "String content for text files, or file reference (@path/to/file) to load content from an external file"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Lines array for text file output with merge strategy support"
            }
          ],
          "description": "File content. Object for JSON/YAML files, string or string[] for text files. Use @path/to/file to reference external template files (paths relative to config file). Supports ${VAR} env interpolation; use $${VAR} to output literal ${VAR}. Omit for empty file."
        },
        "mergeStrategy": {
          "type": "string",
          "enum": [
            "replace",
            "append",
            "prepend"
          ],
          "default": "replace",
          "description": "Array merge strategy for this file. 'replace' replaces arrays, 'append' adds overlay after base, 'prepend' adds overlay before base. Default: replace"
        },
        "createOnly": {
          "type": "boolean",
          "default": false,
          "description": "If true, only create this file if it doesn't already exist in the target repo. Useful for files like .trivyignore or .prettierignore where you want to provide defaults but let repos customize. Default: false"
        },
        "header": {
          "oneOf": [
            {
              "type": "string",
              "description": "Single comment line"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Multiple comment lines"
            }
          ],
          "description": "YAML only. Comment line(s) added at the top of YAML files. Each line gets a '# ' prefix. Ignored for JSON and text files."
        },
        "schemaUrl": {
          "type": "string",
          "description": "YAML only. URL for yaml-language-server schema directive. Adds '# yaml-language-server: $schema=<url>' at the top of YAML files. For JSON files, use $schema property in content instead."
        },
        "executable": {
          "type": "boolean",
          "description": "Mark the file as executable via git update-index --add --chmod=+x. Shell scripts (.sh) are auto-executable unless explicitly set to false. Non-.sh files can be marked executable by setting to true."
        },
        "template": {
          "type": "boolean",
          "default": false,
          "description": "Enable xfg templating for this file. When true, ${xfg:variable} placeholders are replaced with repo-specific values. Available variables: repo.name, repo.owner, repo.fullName, repo.url, repo.platform, repo.host, file.name, date, and any custom vars. Use $${xfg:...} to output literal ${xfg:...}. Default: false"
        },
        "vars": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Custom template variables for this file. Accessible as ${xfg:varName} when template: true. Per-repo vars merge with (and override) these root-level vars."
        },
        "deleteOrphaned": {
          "type": "boolean",
          "default": false,
          "description": "Track this file for orphan deletion. When true, if this file is removed from the config, it will be deleted from target repos. Tracked via .xfg.json manifest. Overrides global deleteOrphaned setting. Default: false"
        }
      }
    },
    "repo": {
      "type": "object",
      "description": "Repository configuration",
      "required": [
        "git"
      ],
      "properties": {
        "git": {
          "oneOf": [
            {
              "type": "string",
              "description": "Single Git repository URL"
            },
            {
              "type": "array",
              "description": "Multiple Git repository URLs (each becomes a separate sync target)",
              "items": {
                "type": "string"
              },
              "minItems": 1
            }
          ],
          "description": "Git repository URL(s). Supports GitHub (git@github.com:owner/repo.git, https://github.com/owner/repo.git) and Azure DevOps formats"
        },
        "files": {
          "type": "object",
          "description": "Per-repo file overrides or exclusions. Keys must reference files defined in the root 'files' object. Set to false to exclude a file from this repo. Set inherit: false to skip all inherited files.",
          "properties": {
            "inherit": {
              "type": "boolean",
              "description": "Set to false to skip all inherited root files. Default: true"
            }
          },
          "additionalProperties": {
            "oneOf": [
              {
                "type": "boolean",
                "const": false,
                "description": "Set to false to exclude this file from this repo"
              },
              {
                "$ref": "#/definitions/repoFileOverride"
              }
            ]
          }
        },
        "prOptions": {
          "$ref": "#/definitions/prOptions",
          "description": "Per-repo PR merge options. Overrides global prOptions."
        },
        "settings": {
          "$ref": "#/definitions/repoSettings",
          "description": "Per-repo settings including GitHub Rulesets. Merged with global settings: per-repo rulesets override root rulesets with same name."
        }
      }
    },
    "prOptions": {
      "type": "object",
      "description": "PR merge behavior options",
      "properties": {
        "merge": {
          "type": "string",
          "enum": [
            "manual",
            "auto",
            "force",
            "direct"
          ],
          "default": "auto",
          "description": "Merge mode: 'manual' leaves PR open for review, 'auto' enables auto-merge when checks pass, 'force' bypasses requirements using admin privileges, 'direct' pushes directly to default branch without creating a PR. Default: auto"
        },
        "mergeStrategy": {
          "type": "string",
          "enum": [
            "merge",
            "squash",
            "rebase"
          ],
          "default": "squash",
          "description": "How to merge the PR: 'merge' creates a merge commit, 'squash' squashes all commits, 'rebase' rebases commits onto base. Default: squash"
        },
        "deleteBranch": {
          "type": "boolean",
          "default": true,
          "description": "Delete the source branch after merge completes. Default: true"
        },
        "bypassReason": {
          "type": "string",
          "description": "Reason for bypassing policies (Azure DevOps only, required when merge=force)"
        }
      }
    },
    "repoFileOverride": {
      "type": "object",
      "description": "Per-repo override for a specific file",
      "properties": {
        "content": {
          "oneOf": [
            {
              "type": "object",
              "description": "Object content overlay for JSON/YAML files. Use $arrayMerge directive to control array merging.",
              "additionalProperties": true
            },
            {
              "type": "string",
              "description": "String content for text files, or file reference (@path/to/file) to load content from an external file"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Lines array for text files (uses merge strategy: replace/append/prepend)"
            }
          ],
          "description": "Content overlay merged onto the file's base content. Use @path/to/file to reference external template files. Must match the content type of the root file definition."
        },
        "override": {
          "type": "boolean",
          "default": false,
          "description": "If true, use only this content and skip merging with base. Default: false"
        },
        "createOnly": {
          "type": "boolean",
          "description": "Override the root-level createOnly setting for this specific repo"
        },
        "header": {
          "oneOf": [
            {
              "type": "string",
              "description": "Single comment line"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Multiple comment lines"
            }
          ],
          "description": "YAML only. Override the root-level header for this specific repo. Ignored for JSON and text files."
        },
        "schemaUrl": {
          "type": "string",
          "description": "YAML only. Override the root-level schemaUrl for this specific repo. For JSON files, use $schema property in content instead."
        },
        "executable": {
          "type": "boolean",
          "description": "Override the root-level executable setting for this specific repo. Set to true to mark executable, or false to disable auto-executable behavior for .sh files."
        },
        "template": {
          "type": "boolean",
          "description": "Override the root-level template setting for this specific repo. Set to true to enable xfg templating, or false to disable it."
        },
        "vars": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Per-repo custom template variables. These merge with (and override) root-level vars for this file. Accessible as ${xfg:varName} when template: true."
        },
        "deleteOrphaned": {
          "type": "boolean",
          "description": "Override the file-level or global deleteOrphaned setting for this specific repo. Set to true to enable orphan tracking, or false to disable it for this repo."
        }
      }
    },
    "repoSettings": {
      "type": "object",
      "description": "Repository settings including GitHub Rulesets and repository features",
      "properties": {
        "rulesets": {
          "type": "object",
          "description": "Map of ruleset names to configurations. Set a ruleset to false to opt out. Set inherit: false to skip all inherited rulesets.",
          "properties": {
            "inherit": {
              "type": "boolean",
              "description": "Set to false to skip all inherited root rulesets. Default: true"
            }
          },
          "additionalProperties": {
            "oneOf": [
              {
                "type": "boolean",
                "const": false,
                "description": "Set to false to opt out of this inherited ruleset"
              },
              {
                "$ref": "#/definitions/ruleset"
              }
            ]
          }
        },
        "repo": {
          "oneOf": [
            {
              "type": "boolean",
              "const": false,
              "description": "Set to false to opt out of all inherited repository settings"
            },
            {
              "$ref": "#/definitions/githubRepoSettings"
            }
          ],
          "description": "GitHub repository settings (features, merge options, security). Set to false at per-repo level to opt out of inherited settings."
        },
        "deleteOrphaned": {
          "type": "boolean",
          "default": false,
          "description": "Track rulesets for orphan deletion. When true, if a ruleset is removed from the config, it will be deleted from the repo. Default: false"
        }
      }
    },
    "githubRepoSettings": {
      "type": "object",
      "description": "GitHub repository settings for features, merge options, and security",
      "properties": {
        "hasIssues": {
          "type": "boolean",
          "description": "Enable or disable GitHub Issues. Warning: Disabling may hide existing issues."
        },
        "hasProjects": {
          "type": "boolean",
          "description": "Enable or disable GitHub Projects. Warning: Disabling may hide existing projects."
        },
        "hasWiki": {
          "type": "boolean",
          "description": "Enable or disable the repository wiki. Warning: Disabling may hide existing wiki content."
        },
        "hasDiscussions": {
          "type": "boolean",
          "description": "Enable or disable GitHub Discussions"
        },
        "isTemplate": {
          "type": "boolean",
          "description": "Mark the repository as a template repository"
        },
        "allowForking": {
          "type": "boolean",
          "description": "Allow forking of a private repository"
        },
        "visibility": {
          "type": "string",
          "enum": [
            "public",
            "private",
            "internal"
          ],
          "description": "Repository visibility. Warning: Changing visibility may expose or hide repository content."
        },
        "archived": {
          "type": "boolean",
          "description": "Archive the repository. Warning: Archived repositories are read-only."
        },
        "allowSquashMerge": {
          "type": "boolean",
          "description": "Allow squash-merging pull requests"
        },
        "allowMergeCommit": {
          "type": "boolean",
          "description": "Allow merge commits for pull requests"
        },
        "allowRebaseMerge": {
          "type": "boolean",
          "description": "Allow rebase-merging pull requests"
        },
        "allowAutoMerge": {
          "type": "boolean",
          "description": "Allow auto-merge on pull requests"
        },
        "deleteBranchOnMerge": {
          "type": "boolean",
          "description": "Automatically delete head branches after pull requests are merged"
        },
        "allowUpdateBranch": {
          "type": "boolean",
          "description": "Show 'Update branch' button in pull requests"
        },
        "squashMergeCommitTitle": {
          "type": "string",
          "enum": [
            "PR_TITLE",
            "COMMIT_OR_PR_TITLE"
          ],
          "description": "Default title for squash merge commits"
        },
        "squashMergeCommitMessage": {
          "type": "string",
          "enum": [
            "PR_BODY",
            "COMMIT_MESSAGES",
            "BLANK"
          ],
          "description": "Default message for squash merge commits"
        },
        "mergeCommitTitle": {
          "type": "string",
          "enum": [
            "PR_TITLE",
            "MERGE_MESSAGE"
          ],
          "description": "Default title for merge commits"
        },
        "mergeCommitMessage": {
          "type": "string",
          "enum": [
            "PR_BODY",
            "PR_TITLE",
            "BLANK"
          ],
          "description": "Default message for merge commits"
        },
        "vulnerabilityAlerts": {
          "type": "boolean",
          "description": "Enable or disable Dependabot vulnerability alerts"
        },
        "automatedSecurityFixes": {
          "type": "boolean",
          "description": "Enable or disable Dependabot automated security fixes"
        },
        "secretScanning": {
          "type": "boolean",
          "description": "Enable or disable secret scanning"
        },
        "secretScanningPushProtection": {
          "type": "boolean",
          "description": "Enable or disable secret scanning push protection"
        },
        "privateVulnerabilityReporting": {
          "type": "boolean",
          "description": "Enable or disable private vulnerability reporting"
        },
        "webCommitSignoffRequired": {
          "type": "boolean",
          "description": "Require contributors to sign off on web-based commits"
        },
        "defaultBranch": {
          "type": "string",
          "description": "The default branch for the repository"
        }
      }
    },
    "ruleset": {
      "type": "object",
      "description": "GitHub Ruleset configuration",
      "properties": {
        "target": {
          "type": "string",
          "enum": [
            "branch",
            "tag"
          ],
          "default": "branch",
          "description": "Target type: 'branch' for branch rules, 'tag' for tag rules. Default: branch"
        },
        "enforcement": {
          "type": "string",
          "enum": [
            "active",
            "disabled",
            "evaluate"
          ],
          "default": "active",
          "description": "Enforcement level: 'active' enforces rules, 'disabled' turns off rules, 'evaluate' evaluates rules without blocking (dry run). Default: active"
        },
        "bypassActors": {
          "type": "array",
          "description": "Actors who can bypass this ruleset",
          "items": {
            "$ref": "#/definitions/bypassActor"
          }
        },
        "conditions": {
          "$ref": "#/definitions/rulesetConditions",
          "description": "Conditions for when this ruleset applies (which branches/tags to target)"
        },
        "rules": {
          "type": "array",
          "description": "Rules to enforce on matching refs",
          "items": {
            "$ref": "#/definitions/rulesetRule"
          }
        }
      }
    },
    "bypassActor": {
      "type": "object",
      "description": "Actor who can bypass ruleset restrictions",
      "required": [
        "actorId",
        "actorType"
      ],
      "properties": {
        "actorId": {
          "type": "integer",
          "description": "The ID of the actor (team ID, user ID, or integration ID)"
        },
        "actorType": {
          "type": "string",
          "enum": [
            "Team",
            "User",
            "Integration"
          ],
          "description": "Type of actor: Team, User, or Integration (GitHub App)"
        },
        "bypassMode": {
          "type": "string",
          "enum": [
            "always",
            "pull_request"
          ],
          "description": "When the actor can bypass: 'always' for all operations, 'pull_request' for PR operations only"
        }
      }
    },
    "rulesetConditions": {
      "type": "object",
      "description": "Conditions for when the ruleset applies",
      "properties": {
        "refName": {
          "type": "object",
          "description": "Ref name patterns to include/exclude",
          "properties": {
            "include": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Patterns to include (e.g., 'refs/heads/main', 'refs/heads/release/*')"
            },
            "exclude": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Patterns to exclude from this ruleset"
            }
          }
        }
      }
    },
    "rulesetRule": {
      "oneOf": [
        {
          "$ref": "#/definitions/pullRequestRule"
        },
        {
          "$ref": "#/definitions/requiredStatusChecksRule"
        },
        {
          "$ref": "#/definitions/requiredSignaturesRule"
        },
        {
          "$ref": "#/definitions/requiredLinearHistoryRule"
        },
        {
          "$ref": "#/definitions/nonFastForwardRule"
        },
        {
          "$ref": "#/definitions/creationRule"
        },
        {
          "$ref": "#/definitions/deletionRule"
        },
        {
          "$ref": "#/definitions/updateRule"
        },
        {
          "$ref": "#/definitions/requiredDeploymentsRule"
        },
        {
          "$ref": "#/definitions/codeScanningRule"
        },
        {
          "$ref": "#/definitions/codeQualityRule"
        },
        {
          "$ref": "#/definitions/workflowsRule"
        },
        {
          "$ref": "#/definitions/patternRule"
        },
        {
          "$ref": "#/definitions/filePathRestrictionRule"
        },
        {
          "$ref": "#/definitions/fileExtensionRestrictionRule"
        },
        {
          "$ref": "#/definitions/maxFilePathLengthRule"
        },
        {
          "$ref": "#/definitions/maxFileSizeRule"
        }
      ]
    },
    "pullRequestRule": {
      "type": "object",
      "description": "Require pull request before merging",
      "required": [
        "type"
      ],
      "properties": {
        "type": {
          "const": "pull_request"
        },
        "parameters": {
          "type": "object",
          "properties": {
            "requiredApprovingReviewCount": {
              "type": "integer",
              "minimum": 0,
              "maximum": 10,
              "description": "Number of required approving reviews"
            },
            "dismissStaleReviewsOnPush": {
              "type": "boolean",
              "description": "Dismiss approving reviews when new commits are pushed"
            },
            "requireCodeOwnerReview": {
              "type": "boolean",
              "description": "Require review from code owners"
            },
            "requireLastPushApproval": {
              "type": "boolean",
              "description": "Require approval from someone other than the last pusher"
            },
            "requiredReviewThreadResolution": {
              "type": "boolean",
              "description": "Require all review threads to be resolved"
            },
            "allowedMergeMethods": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "merge",
                  "squash",
                  "rebase"
                ]
              },
              "description": "Allowed merge methods for PRs"
            },
            "requiredReviewers": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/requiredReviewer"
              },
              "description": "Required reviewers for specific file patterns (beta feature)"
            }
          }
        }
      }
    },
    "requiredReviewer": {
      "type": "object",
      "description": "Required reviewer configuration for specific file patterns",
      "required": [
        "filePatterns",
        "minimumApprovals",
        "reviewer"
      ],
      "properties": {
        "filePatterns": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "File path patterns that require this reviewer"
        },
        "minimumApprovals": {
          "type": "integer",
          "minimum": 1,
          "description": "Minimum number of approvals required from this reviewer"
        },
        "reviewer": {
          "type": "object",
          "required": [
            "id",
            "type"
          ],
          "properties": {
            "id": {
              "type": "integer",
              "description": "Team ID for the reviewer"
            },
            "type": {
              "const": "Team",
              "description": "Reviewer type (currently only Team is supported)"
            }
          }
        }
      }
    },
    "requiredStatusChecksRule": {
      "type": "object",
      "description": "Require status checks to pass",
      "required": [
        "type"
      ],
      "properties": {
        "type": {
          "const": "required_status_checks"
        },
        "parameters": {
          "type": "object",
          "properties": {
            "strictRequiredStatusChecksPolicy": {
              "type": "boolean",
              "description": "Require branches to be up to date before merging"
            },
            "doNotEnforceOnCreate": {
              "type": "boolean",
              "description": "Allow bypassing when creating refs (for initial setup)"
            },
            "requiredStatusChecks": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "context"
                ],
                "properties": {
                  "context": {
                    "type": "string",
                    "description": "Name of the status check"
                  },
                  "integrationId": {
                    "type": "integer",
                    "description": "GitHub App integration ID (optional, for disambiguation)"
                  }
                }
              },
              "description": "List of required status checks"
            }
          }
        }
      }
    },
    "requiredSignaturesRule": {
      "type": "object",
      "description": "Require signed commits",
      "required": [
        "type"
      ],
      "properties": {
        "type": {
          "const": "required_signatures"
        }
      }
    },
    "requiredLinearHistoryRule": {
      "type": "object",
      "description": "Require linear history (no merge commits)",
      "required": [
        "type"
      ],
      "properties": {
        "type": {
          "const": "required_linear_history"
        }
      }
    },
    "nonFastForwardRule": {
      "type": "object",
      "description": "Prevent force pushes",
      "required": [
        "type"
      ],
      "properties": {
        "type": {
          "const": "non_fast_forward"
        }
      }
    },
    "creationRule": {
      "type": "object",
      "description": "Restrict ref creation",
      "required": [
        "type"
      ],
      "properties": {
        "type": {
          "const": "creation"
        }
      }
    },
    "deletionRule": {
      "type": "object",
      "description": "Restrict ref deletion",
      "required": [
        "type"
      ],
      "properties": {
        "type": {
          "const": "deletion"
        }
      }
    },
    "updateRule": {
      "type": "object",
      "description": "Restrict updates to refs",
      "required": [
        "type"
      ],
      "properties": {
        "type": {
          "const": "update"
        },
        "parameters": {
          "type": "object",
          "properties": {
            "updateAllowsFetchAndMerge": {
              "type": "boolean",
              "description": "Allow fetch and merge updates (for forks)"
            }
          }
        }
      }
    },
    "requiredDeploymentsRule": {
      "type": "object",
      "description": "Require deployments to succeed",
      "required": [
        "type"
      ],
      "properties": {
        "type": {
          "const": "required_deployments"
        },
        "parameters": {
          "type": "object",
          "properties": {
            "requiredDeploymentEnvironments": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Environments that must have successful deployments"
            }
          }
        }
      }
    },
    "codeScanningRule": {
      "type": "object",
      "description": "Require code scanning results",
      "required": [
        "type"
      ],
      "properties": {
        "type": {
          "const": "code_scanning"
        },
        "parameters": {
          "type": "object",
          "properties": {
            "codeScanningTools": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "tool",
                  "alertsThreshold",
                  "securityAlertsThreshold"
                ],
                "properties": {
                  "tool": {
                    "type": "string",
                    "description": "Name of the code scanning tool (e.g., 'CodeQL')"
                  },
                  "alertsThreshold": {
                    "type": "string",
                    "enum": [
                      "none",
                      "errors",
                      "errors_and_warnings",
                      "all"
                    ],
                    "description": "Alert threshold for general code quality"
                  },
                  "securityAlertsThreshold": {
                    "type": "string",
                    "enum": [
                      "none",
                      "critical",
                      "high_or_higher",
                      "medium_or_higher",
                      "all"
                    ],
                    "description": "Alert threshold for security issues"
                  }
                }
              },
              "description": "Code scanning tool configurations"
            }
          }
        }
      }
    },
    "codeQualityRule": {
      "type": "object",
      "description": "Require code quality checks",
      "required": [
        "type"
      ],
      "properties": {
        "type": {
          "const": "code_quality"
        },
        "parameters": {
          "type": "object",
          "properties": {
            "severity": {
              "type": "string",
              "enum": [
                "errors",
                "errors_and_warnings",
                "all"
              ],
              "description": "Minimum severity level to enforce"
            }
          }
        }
      }
    },
    "workflowsRule": {
      "type": "object",
      "description": "Require specific workflows to pass",
      "required": [
        "type"
      ],
      "properties": {
        "type": {
          "const": "workflows"
        },
        "parameters": {
          "type": "object",
          "properties": {
            "doNotEnforceOnCreate": {
              "type": "boolean",
              "description": "Allow bypassing when creating refs"
            },
            "workflows": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "path",
                  "repositoryId"
                ],
                "properties": {
                  "path": {
                    "type": "string",
                    "description": "Path to workflow file (e.g., '.github/workflows/ci.yml')"
                  },
                  "repositoryId": {
                    "type": "integer",
                    "description": "Repository ID where the workflow is defined"
                  },
                  "ref": {
                    "type": "string",
                    "description": "Git ref to use for the workflow (branch/tag)"
                  },
                  "sha": {
                    "type": "string",
                    "description": "Specific commit SHA for the workflow"
                  }
                }
              },
              "description": "Required workflows"
            }
          }
        }
      }
    },
    "patternRule": {
      "type": "object",
      "description": "Pattern-based rules for commit messages, author emails, etc.",
      "required": [
        "type",
        "parameters"
      ],
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "commit_author_email_pattern",
            "commit_message_pattern",
            "committer_email_pattern",
            "branch_name_pattern",
            "tag_name_pattern"
          ],
          "description": "Pattern rule type"
        },
        "parameters": {
          "type": "object",
          "required": [
            "operator",
            "pattern"
          ],
          "properties": {
            "name": {
              "type": "string",
              "description": "Name for this pattern rule (for display)"
            },
            "negate": {
              "type": "boolean",
              "description": "Negate the pattern (require NOT matching)"
            },
            "operator": {
              "type": "string",
              "enum": [
                "starts_with",
                "ends_with",
                "contains",
                "regex"
              ],
              "description": "Pattern matching operator"
            },
            "pattern": {
              "type": "string",
              "description": "Pattern to match against"
            }
          }
        }
      }
    },
    "filePathRestrictionRule": {
      "type": "object",
      "description": "Restrict changes to specific file paths",
      "required": [
        "type"
      ],
      "properties": {
        "type": {
          "const": "file_path_restriction"
        },
        "parameters": {
          "type": "object",
          "properties": {
            "restrictedFilePaths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "File paths that are restricted from changes"
            }
          }
        }
      }
    },
    "fileExtensionRestrictionRule": {
      "type": "object",
      "description": "Restrict changes to files with specific extensions",
      "required": [
        "type"
      ],
      "properties": {
        "type": {
          "const": "file_extension_restriction"
        },
        "parameters": {
          "type": "object",
          "properties": {
            "restrictedFileExtensions": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "File extensions that are restricted"
            }
          }
        }
      }
    },
    "maxFilePathLengthRule": {
      "type": "object",
      "description": "Restrict maximum file path length",
      "required": [
        "type"
      ],
      "properties": {
        "type": {
          "const": "max_file_path_length"
        },
        "parameters": {
          "type": "object",
          "properties": {
            "maxFilePathLength": {
              "type": "integer",
              "minimum": 1,
              "description": "Maximum allowed file path length"
            }
          }
        }
      }
    },
    "maxFileSizeRule": {
      "type": "object",
      "description": "Restrict maximum file size",
      "required": [
        "type"
      ],
      "properties": {
        "type": {
          "const": "max_file_size"
        },
        "parameters": {
          "type": "object",
          "properties": {
            "maxFileSize": {
              "type": "integer",
              "minimum": 1,
              "description": "Maximum allowed file size in bytes"
            }
          }
        }
      }
    }
  }
}
